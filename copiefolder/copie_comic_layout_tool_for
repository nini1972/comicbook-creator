from pathlib import Path
from crewai.tools import BaseTool
from pydantic import BaseModel, Field
from typing import List, Optional, Type
import os
import shutil
import glob
from datetime import datetime, timedelta
from src.utils.image_utils import clean_temp_folder
from src.utils.comic_exporter import ComicExporter
from src.utils.registry_utils import update_registry_entry
from datetime import datetime
from src.utils.path_utils import get_backend_output_path
from src.utils.registry_utils import _ensure_registry_exists, read_registry, update_registry_entry
from src.utils.panel_registry_inspector_utils import verify_image, inspect_panel_registry


# Panel registry inspection should be done after image_paths and dialogue are available in _run

class ComicLayoutInput(BaseModel):
    panels: Optional[List[str]] = Field(None, description="List of panel descriptions in order")
    dialogue: Optional[List[str]] = Field(None, description="List of dialogue for each panel (same length as panels)")
    image_paths: Optional[List[str]] = Field(
        None,
        description="Optional list of image file paths corresponding 1:1 with panels."
    )
    story_text: Optional[str] = Field(None, description="The full story text to extract panels and dialogue from if not provided directly")

class ComicLayoutTool(BaseTool):
    name: str = "ComicLayoutTool"
    description: str = (
        "Takes lists of panel descriptions and matching dialogue lines and returns a markdown comic layout. "
        "Can also extract panel descriptions and dialogue from a story text if provided. "
        "Use after all panels and dialogue are finalized or when you have a complete story to parse."
    )
    args_schema: Type[BaseModel] = ComicLayoutInput

    def _discover_recent_images(self, expected_count: int) -> Optional[List[str]]:
        """Discover recently generated images from the backend comic_panels directory."""
        try:
            # Look for images in the backend output directory
            comic_panels_dir = get_backend_output_path("comic_panels")

            if not os.path.exists(comic_panels_dir):
                print(f"[ComicLayoutTool] Directory not found: {comic_panels_dir}")
                return None

            # Get all PNG files sorted by modification time (newest first)
            pattern = os.path.join(comic_panels_dir, "*.png")
            image_files = glob.glob(pattern)

            if not image_files:
                print("[ComicLayoutTool] No PNG files found in comic_panels directory")
                return None

            # Sort by modification time (newest first)
            image_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)

            # Filter to recent images (within last 10 minutes to catch current generation)
            recent_cutoff = datetime.now() - timedelta(minutes=10)
            recent_images = []

            for img_file in image_files:
                mod_time = datetime.fromtimestamp(os.path.getmtime(img_file))
                if mod_time >= recent_cutoff:
                    recent_images.append(img_file)

            if not recent_images:
                print("[ComicLayoutTool] No recent images found (within 10 minutes)")
                return None

            print(f"[ComicLayoutTool] Found {len(recent_images)} recent images")

            # Take the most recent images up to expected count
            selected_images = recent_images[:expected_count]

            # Pad with None if we don't have enough images
            while len(selected_images) < expected_count:
                selected_images.append(None)

            return selected_images
        except Exception as e:
            print(f"[ComicLayoutTool] Error discovering images: {e}")
            return None


    def _run(self, panels: List[str] = None, dialogue: List[str] = None, image_paths: Optional[List[str]] = None, story_text: Optional[str] = None) -> str:
        print("DEBUG: ComicLayoutTool._run called")
        print(f"DEBUG: panels: {panels}")
        print(f"DEBUG: dialogue: {dialogue}")
        print(f"DEBUG: image_paths: {image_paths}")
        print(f"DEBUG: story_text provided: {story_text is not None}")
        
        # If panels and dialogue are not provided but story_text is, extract them
        if (not panels or not dialogue) and story_text:
            print("DEBUG: Extracting panels and dialogue from story_text")
            # Use a simple extraction method for now
            # In a real implementation, you might want to use a more sophisticated NLP approach
            sentences = story_text.split('. ')
            # Create 6 panels by distributing sentences
            panels = []
            dialogue = []
            sentences_per_panel = max(1, len(sentences) // 6)
            for i in range(6):
                start = i * sentences_per_panel
                end = min((i + 1) * sentences_per_panel, len(sentences))
                panel_text = '. '.join(sentences[start:end])
                if panel_text:
                    panel_text += '.'
                panels.append(panel_text)
                dialogue.append("")  # Empty dialogue as default
            
            # Ensure we have exactly 6 panels and dialogues
            while len(panels) < 6:
                panels.append("")
                dialogue.append("")
            panels = panels[:6]
            dialogue = dialogue[:6]
            print(f"DEBUG: Extracted panels: {panels}")
            print(f"DEBUG: Extracted dialogue: {dialogue}")
        
        # Validate inputs
        if not panels or not dialogue:
            return "Error: panels and dialogue must be provided either directly or through story_text extraction."
            
        if len(panels) != len(dialogue):
            return (
                f"Error: panels ({len(panels)}) and dialogue ({len(dialogue)}) count mismatch. "
                "They must be the same length."
            )
        if image_paths and len(image_paths) != len(panels):
            return (
                f"Error: image_paths ({len(image_paths)}) length must match panels ({len(panels)})."
            )
        
        # PREFERRED METHOD: Get image paths from panel registry
        try:
            registry = read_registry()
            if registry:
                image_paths = []
                # Get the backend output path for constructing full paths
                backend_output_path = get_backend_output_path("comic_panels")
                for i in range(1, len(panels) + 1):
                    panel_id = f"panel_{i}"
                    if panel_id in registry and 'filename' in registry[panel_id] and registry[panel_id].get('verified', False):
                        # Use the verified filename from registry and construct full path
                        filename = registry[panel_id]['filename']
                        full_path = os.path.join(backend_output_path, filename)
                        image_paths.append(full_path)
                    else:
                        # If registry entry not found or not verified, use None to indicate missing panel
                        image_paths.append(None)
                print(f"[ComicLayoutTool] Using image paths from registry: {image_paths}")
            else:
                print("[ComicLayoutTool] No registry data found, falling back to auto-discovery...")
                # If no image paths provided and no registry data, try to discover recent images automatically
                if not image_paths:
                    print("[ComicLayoutTool] No image paths provided, attempting auto-discovery...")
                    image_paths = self._discover_recent_images(len(panels))
        except Exception as e:
            print(f"[ComicLayoutTool] Error reading registry: {e}")
            # If registry reading fails, fall back to auto-discovery
            if not image_paths:
                print("[ComicLayoutTool] Registry read failed, attempting auto-discovery...")
                image_paths = self._discover_recent_images(len(panels))

        # Inspect panel registry before proceeding
        is_valid, report = inspect_panel_registry(image_paths, dialogue)
        for line in report:
            print(line)
        if not is_valid:
            return "Panel registry inspection failed. Aborting layout."
        
        
        layout_lines = ["# Comic Strip Layout", ""]
        for i, dial in enumerate(dialogue, start=1):
            if image_paths and i <= len(image_paths) and image_paths[i-1]:
                # Extract just the filename for the frontend path
                filename = os.path.basename(image_paths[i-1])
                img_path = f"/comic_panels/{filename}"
                layout_lines.append(f"![Panel {i}]({img_path})")

            layout_lines.append(f"Dialogue: {dial}")
            layout_lines.append("")
                                         
        markdown_output = "\n".join(layout_lines)
        return markdown_output

    

    